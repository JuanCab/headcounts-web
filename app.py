import datetime
import os
import logging
import sys
import re

import numpy as np
from flask import Flask, render_template, request, send_from_directory
from astropy.table import Table, Column

from flask_bootstrap import Bootstrap

##
## Define functions
##
def parse_year_term(year_term_str):
    """
    Given a year/term code as a string return a human-readable
    year and term.

    Parameters
    ----------
    year_term_str : str
        A string representing the fiscal year and term, such as '20231',
        '20233', '20235', etc. The last digit indicates the term:
        - '1' for Summer
        - '3' for Fall
        - '5' for Spring
       NOTE: Since fiscal years start in the summer, the year is
       represented as the year of the summer term, so '20231' is
       Summer 2022, '20233' is Fall 2022, and '20235' is Spring 2023.

    Returns
    -------
    str
        A human-readable string representing the term, such as 'Summer 2022',
        'Fall 2022', or 'Spring 2023'.
    """

    # Define a mapping of term numbers to human-readable names
    term_names = {1: 'Summer', 3: 'Fall', 5: 'Spring'}
    term = int(year_term_str[-1])

    # Extract fiscal year and convert to actual year
    fiscal_year = int(year_term_str[:-1])
    if term < 5:
        year = fiscal_year - 1
    else:
        year = fiscal_year

    # Return the formatted string with the term name and year
    return f"{term_names.get(term, 'Unknown')} {year}"


def filled_credits(credit_column, variable_credits=1):
    """
    Convert the 'Crds' column in the table to a numeric format,
    filling in variable credits with a specified value.

    Parameters
    ----------
    credit_column : astropy Column
        The column containing credit information, which may include
        variable credits represented as 'Vari.'.
    variable_credits : int, optional
        The value to use for variable credits, by default 1.

    Returns
    ------- 
    np.ndarray
        An array of integer credits, with variable credits replaced
        by the specified value.
    """

    # Identify rows where the credit value is 'Vari.'
    vari_rows = credit_column == 'Vari.'

    # Create a copy of the credit column, masking the variable rows
    # and filling them with the specified variable credits value
    crds = credit_column.copy()
    crds.mask[vari_rows] = True
    crds.fill_value = variable_credits

    # Convert the filled column to float, round it, and then convert
    # to int
    crds = np.round(crds.filled().astype(float)).astype(int)
    return crds


def calc_sch(table, vari_credits=1):
    """
    Calculate total student credit hours generated by courses in this 
    table.

    Parameters
    ----------
    table : astropy Table
        The table containing course data, including 'Crds' and 'Enrolled'
        columns.
    vari_credits : int, optional
        The value to use for variable credits, by default 1.

    Returns
    -------
    int
        The total student credit hours (SCH) calculated as the sum of
        enrolled students multiplied by their respective credits.
    """

    # Fill the 'Crds' column with variable credits where applicable
    crds = filled_credits(table['Crds'], variable_credits=vari_credits)

    # Calculate the total student credit hours by multiplying
    # the number of enrolled students by their respective credits
    # and summing the results
    sch = (table['Enrolled'] * crds).sum()

    return sch


def calc_seats(table):
    """
    Calculate the number of seats that are available, filled, empty, for
    classes that are not canceled.

    Parameters
    ----------
    table : astropy Table
        The table containing course data, including 'Status', 'Size:',
        and 'Enrolled' columns.

    Returns
    -------
    dict
        A dictionary containing the number of empty seats, filled seats,
        and available seats in the courses that are not canceled.
        The keys are 'empty', 'filled', and 'available'.
    """

    # Filter out canceled courses
    not_canceled = table['Status'] != 'Cancelled'
    # Calculate the number of empty seats for courses that are not canceled
    # and where the size is greater than the number of enrolled students.
    empty = table['Size:'] - table['Enrolled']
    # Only keep positive empty seats
    positive = empty > 0
    empty *= positive

    # Sum the empty, filled, and available seats for courses that are 
    # not canceled
    empty = empty[not_canceled].sum()
    available = table['Size:'][not_canceled].sum()
    filled = table['Enrolled'][not_canceled].sum()
    return {'empty': empty, 'filled': filled, 'available': available}


def calc_tuition(table, variable_credits=1):
    """
    Calculate the tuition revenue generated by the courses in the
    table.

    Parameters
    ----------
    table : astropy Table
        The table containing course data, including 'Tuition unit',
        'Crds', 'Tuition -resident', and 'Enrolled' columns.
    variable_credits : int, optional
        The value to use for variable credits, by default 1.

    Returns
    -------
    float
        The total tuition revenue calculated as the sum of enrolled
        students multiplied by their respective tuition amounts, adjusted
        for credit hours if applicable.
    """
    by_credit = table['Tuition unit'] == 'credit'
    credits = filled_credits(table['Crds'],
                             variable_credits=variable_credits)
    tuition_nas = table['Tuition -resident'] == 'n/a'
    table['Tuition -resident'].mask |= tuition_nas
    # parse tuition as a string into a number
    money = [float(m.replace('$', '').replace(',', '')) for m in table['Tuition -resident'].filled(fill_value='0')]
    money *= table['Enrolled']
    money[by_credit] *= credits[by_credit]
    return money.sum()


def gen_cache_file(path, table):
    """
    Generate a name for a cache of a view of the data based on
    the URL path to the view

    Parameters
    ----------
    path : str
        The URL path that got the user here, used to generate a unique
        filename for the cached data.
    table : astropy Table
        The table containing course data to be cached.

    Returns
    -------
    str
        The name of the cached file, which is a CSV file containing the
        course data for the specified view.
    """
    # path always starts with a leading /, remove it
    rel_path = path[1:]
    parts = rel_path.split('/')
    parts.extend([str(avg_time)])
    name = '-'.join(parts) + '.csv'
    file_path = os.path.join(CACHE_DIR, name)
    if not os.path.isfile(file_path):
        table.write(file_path)
    return name


def match_subject(subject, tbl):
    """
    Match the subject to the table, filtering it down to only the
    relevant courses.

    Parameters
    ----------

    subject : str
        The subject to filter by, which can be a course subject (e.g., 'CSCI'),
        a LASC area ('lasc'), a WI course ('wi'), or '18online' for online courses.
    tbl : astropy Table
        The table containing course data to be filtered.

    Returns
    -------
    astropy Table
        A filtered table containing only the courses that match the specified
        subject. If the subject is 'lasc', it filters for LASC courses; if 'wi',
        it filters for WI courses; if '18online', it filters for online courses;
        if 'all', it returns the entire table; otherwise, it filters by the
        specified course subject.
    """
    
    if subject == 'lasc':
        render_me = tbl[~tbl['LASC/WI'].mask]
        really_lasc = np.array([len(lasc.strip('WI')) > 0 for lasc in render_me['LASC/WI']])
        render_me = render_me[really_lasc]
    elif subject == 'wi':
        render_me = tbl[~tbl['LASC/WI'].mask]
        really_wi = np.array(['WI' in lasc for lasc in render_me['LASC/WI']])
        render_me = render_me[really_wi]
    elif subject == '18online':
        keep = tbl['18online'] == 'True'
        render_me = tbl[keep]
    elif subject == 'all':
        render_me = tbl.copy()
    else:
        # Regular academic subject...
        keep = tbl['Subj'] == subject.upper()
        render_me = tbl[keep]
    return render_me


def common_response(render_me, path):
    """
    Most of what we are returning is the same for all views,
    we just have a bunch of routes for getting there.

    Parameters
    ----------
    render_me : astropy Table
        The table to be rendered in the view.

    path : str
        The URL path that got the user here.

    Returns
    -------
    str
        The rendered HTML template for the course information page,
        including the table, timestamp, most recent term, year terms,
        cache file name, student credit hours, available seats, and
        tuition revenue.
    """
    terms = sorted(set(render_me['year_term']))
    year_terms = ', '.join([parse_year_term(str(t)) for t in terms])
    file_name = gen_cache_file(path, render_me)
    most_recent = int(render_me['timestamp'].max())
    most_recent = datetime.datetime.fromtimestamp(most_recent)
    oldest = render_me['timestamp'].min()
    return render_template('course_info.html', table=render_me,
                           timestamp=timestamp,
                           most_recent=most_recent,
                           year_term=year_terms,
                           sch=calc_sch(render_me),
                           filename=file_name,
                           seats=calc_seats(render_me),
                           revenue=calc_tuition(render_me),
                           base_detail_url=COURSE_DETAIL_URL)


##
## MAIN CODE
##

# Define the base URL for course detail pages
# The placeholders in the URL will be replaced with actual course data
COURSE_DETAIL_URL = 'https://eservices.minnstate.edu/registration/search/detail.html?campusid=072&courseid={course_id}&yrtr={year_term}&rcid=0072&localrcid=0072&partnered=false&parent=search'

# Define the directory where cached CSV files will be stored
CACHE_DIR = 'viewed-csvs'

# Initialize the Flask application
app = Flask(__name__)

# Integrate Bootstrap for styling the Flask app
bootstrap = Bootstrap(app)

# Configure logging to output error messages to the console and set
# the logging level to ERROR to avoid cluttering the console with 
# non-error messages
app.logger.addHandler(logging.StreamHandler(sys.stdout))
app.logger.setLevel(logging.ERROR)

# Read the enrollment data from a CSV file into an Astropy Table
# The `ascii.csv` format is used to parse the CSV file
table = Table.read('all_enrollments.csv', format='ascii.csv')

# Calculate the average timestamp from the 'timestamp' column in the
# table This represents the average time across all entries in the
# dataset
avg_time = int(table['timestamp'].mean())

# Convert the average Unix timestamp into a human-readable datetime
# object The `fromtimestamp` method assumes the timestamp is in seconds
# since the epoch (UTC)
timestamp = datetime.datetime.fromtimestamp(avg_time)

# Sort the table by 'year_term', 'Subj', and '#' columns
# This ensures the data is ordered logically for further processing
table.sort(['year_term', 'Subj', '#'])

# Attempt to create the cache directory if it does not already exist
# otherwise, ignore the error if it already exists
try:
    os.mkdir(CACHE_DIR)
except OSError:
    pass

# Compute and add a human-readable year-term column to astropy Table
human_yrtr = [parse_year_term(str(yrtr)) for yrtr in table['year_term']]
human_yrtr = Column(data=human_yrtr, name='Term')
table.add_column(human_yrtr, index=0)


# Define the route for the root URL of the application This route serves
# the instructions page when the user accesses the root URL It renders
# the 'instructions.html' template, which contains information on how to
# use the application
@app.route('/')
def index():
    return render_template('instructions.html', )


# Define the route for the /<subject>/<spec1>/<spec2> URL pattern This
# route handles requests for specific subjects and specifications It can
# accept up to two specifications (spec1 and spec2) after the subject
@app.route('/<subject>')
@app.route('/<subject>/<spec1>')
@app.route('/<subject>/<spec1>/<spec2>')
def subtable_spec(subject, spec1=None, spec2=None):
    # Check if the subject is 'favicon.ico' and return an empty string
    # to avoid processing requests for the favicon
    if subject == 'favicon.ico':
        return ''
    
    render_me = match_subject(subject, table)
    specs = [spec1, spec2]
    specs = [s for s in specs if s is not None]
    if not specs and subject != 'all':
        terms = sorted(set(render_me['year_term']))
        most_recent = terms[-1]
        keep = render_me['year_term'] == most_recent
        render_me = render_me[keep]
    else:
        for spec in specs:
            if spec != 'all':
                if len(spec) == 5 and spec[-1] in ['1', '3', '5']:
                    # spec probably a year/term, filter by it:
                    keep = render_me['year_term'] == int(spec)
                elif (re.match('[a-z]{2,4}', spec.lower()) and
                      spec.lower() not in ['lasc', 'wi']):
                    # spec is probably a course rubric, filter by it:
                    keep = render_me['Subj'] == spec.upper()
                else:
                    # Assume it was a course number or LASC area
                    if subject == 'lasc':
                        keep = np.array([spec in l for l in render_me['LASC/WI']])
                    else:
                        keep = render_me['#'] == str(spec)

                render_me = render_me[keep]

    return common_response(render_me, request.path)


# Define the route for downloading a cached CSV file
# This route allows users to download a specific file from the cache
# The filename is passed as a parameter in the URL
@app.route('/download/<filename>')
def download(filename):
    # Thanks to this Stack Overflow answer for the idea of
    # using `send_from_directory` to serve files from a directory:
    # https://stackoverflow.com/questions/34009980/return-a-download-and-rendered-page-in-one-flask-response
    return send_from_directory(CACHE_DIR, filename)


# Define the application entry point
if __name__ == '__main__':
    app.run(debug=True)
