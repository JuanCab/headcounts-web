import datetime
import os

import numpy as np
from flask import Flask, render_template, request, send_from_directory
from astropy.table import Table

from flask.ext.bootstrap import Bootstrap

app = Flask(__name__)
bootstrap = Bootstrap(app)

table = Table.read('all_enrollments.csv', format='ascii.csv')

avg_time = int(table['timestamp'].mean())
timestamp = datetime.datetime.fromtimestamp(avg_time)
# We are done with the timestamp column, so nuke it
table.remove_column('timestamp')
year_term = str(table['year_term'][0])
year_term_2 = '0'

CACHE_DIR = 'viewed-csvs'

try:
    os.mkdir(CACHE_DIR)
except OSError:
    pass


def parse_year_term(year_term_str):
    """
    Given a year/term code as a string return a human-readable
    year and term.
    """
    if year_term_str[-1] == '1':
        year_term = year_term_str[:-1]
        year_term = int(year_term)
        year_term = year_term - 1
        year_term_2 = 'Summer'
    elif year_term_str[-1] == '3':
        year_term = year_term_str[:-1]
        year_term = int(year_term)
        year_term = year_term - 1
        year_term_2 = 'Fall'
    elif year_term_str[-1] == '5':
        year_term = year_term_str[:-1]
        year_term_2 = 'Spring'
    else:
        year_term = 'Unknown'
        year_term_2 = 'Unknown'
    return ' '.join((year_term_2, str(year_term)))


def calc_sch(table, vari_credits=1):
    """
    Calculate total student credit hours generated by courses in this table.
    """
    vari_rows = table['Crds'] == 'Vari.'
    crds = table['Crds'].copy()
    crds.mask[vari_rows] = True
    crds.fill_value = 0
    crds = np.round(crds.filled().astype(np.float)).astype(np.int)
    sch = (table['Enrolled'] * crds).sum()
    return sch


def calc_seats(table):
    """
    Calculate the number of seats that are available, filled, empty, for
    classes that are not canceled.
    """
    not_canceled = table['Status'] != 'Cancelled'
    empty = table['Size:'] - table['Enrolled']
    empty = empty[not_canceled].sum()
    available = table['Size:'][not_canceled].sum()
    filled = table['Enrolled'][not_canceled].sum()
    return {'empty': empty, 'filled': filled, 'available': available}


def gen_cache_file(path, table):
    """
    Generate a name for a cache of a view of the data based on
    the URL path to the view
    """
    # path always starts with a leading /, remove it
    rel_path = path[1:]
    parts = rel_path.split('/')
    parts.extend([str(avg_time)])
    name = '-'.join(parts) + '.csv'
    file_path = os.path.join(CACHE_DIR, name)
    if not os.path.isfile(file_path):
        table.write(file_path)
    return name


def match_subject(subject, tbl):
    if subject == 'lasc':
        render_me = tbl[~tbl['LASC/WI'].mask]
        really_lasc = np.array([len(lasc.strip('WI')) > 0 for lasc in render_me['LASC/WI']])
        render_me = render_me[really_lasc]
    elif subject == 'wi':
        render_me = tbl[~tbl['LASC/WI'].mask]
        really_wi = np.array(['WI' in lasc for lasc in render_me['LASC/WI']])
        render_me = render_me[really_wi]
    elif subject == '18online':
        keep = tbl['18online'] == 'True'
        render_me = tbl[keep]
    else:
        # Regular academic subject...
        keep = tbl['Subj'] == subject.upper()
        render_me = tbl[keep]
    return render_me


def common_response(render_me, path):
    """
    Most of what we are returning is the same for all views,
    we just have a bunch of routes for getting there.

    Parameters
    ----------

    render_me : astropy Table
        The table to be rendered in the view.

    path : str
        The URL path that got the user here.
    """
    terms = sorted(set(render_me['year_term']))
    year_terms = ', '.join([parse_year_term(str(t)) for t in terms])
    file_name = gen_cache_file(path, render_me)
    return render_template('course_info.html', table=render_me,
                           timestamp=timestamp,
                           year_term=year_terms,
                           sch=calc_sch(render_me),
                           filename=file_name,
                           seats=calc_seats(render_me))


@app.route('/')
def index():
    return render_template('instructions.html', )


@app.route('/all')
def user():
    return render_template('course_info.html', table=table,
                           timestamp=timestamp)


# @app.route('/<subject>')
# def subtable(subject):
#     keep = table['Subj'] == subject.upper()
#     render_me = table[keep]
#     terms = sorted(set(render_me['year_term']))
#     most_recent = terms[-1]
#     keep = render_me['year_term'] == most_recent
#     render_me = render_me[keep]
#     return common_response(render_me, request.path)

@app.route('/<subject>')
@app.route('/<subject>/<spec>')
def subtable_spec(subject, spec=None):
    render_me = match_subject(subject, table)

    if spec is None:
        terms = sorted(set(render_me['year_term']))
        most_recent = terms[-1]
        keep = render_me['year_term'] == most_recent
        render_me = render_me[keep]
    else:
        if spec != 'all':
            if len(spec) == 5 and spec[-1] in ['1', '3', '5']:
                # spec probably a year/term, filter by it
                keep = render_me['year_term'] == int(spec)
            else:
                # Assume it was a course number
                keep = render_me['#'] == str(spec)

            render_me = render_me[keep]

    return common_response(render_me, request.path)


# @app.route('/lasc')
# def lasc_courses():
#     render_me = table[~table['LASC/WI'].mask]
#     really_lasc = np.array([len(lasc.strip('WI')) > 0 for lasc in render_me['LASC/WI']])
#     render_me = render_me[really_lasc]
#     return common_response(render_me, request.path)


@app.route('/download/<filename>')
def download(filename):
    # https://stackoverflow.com/questions/34009980/return-a-download-and-rendered-page-in-one-flask-response
    return send_from_directory(CACHE_DIR, filename)

# More routes:
#
# /LASC -- All LASC courses, most recent term
# /<subject> or LASC/year_term -- subject or LASC, specified term
# /<subject> or LASC/number (not a year_term) -- just that course or LASC area
# ../all -- whatever precedes these, for all terms


if __name__ == '__main__':
    app.run(debug=True)
