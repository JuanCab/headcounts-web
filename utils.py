import datetime
import os

import numpy as np
from flask import render_template

from config import COURSE_DETAIL_URL, CACHE_DIR

# This is an importable file of utility functions for the Flask app.

def parse_year_term(year_term_str):
    """
    Given a year/term code as a string return a human-readable
    year and term.

    Parameters
    ----------
    year_term_str : str
        A string representing the fiscal year and term, such as '20231',
        '20233', '20235', etc. The last digit indicates the term:
        - '1' for Summer
        - '3' for Fall
        - '5' for Spring
       NOTE: Since fiscal years start in the summer, the year is
       represented as the year of the summer term, so '20231' is
       Summer 2022, '20233' is Fall 2022, and '20235' is Spring 2023.

    Returns
    -------
    str
        A human-readable string representing the term, such as 'Summer 2022',
        'Fall 2022', or 'Spring 2023'.
    """
    # Define a mapping of term numbers to human-readable names
    term_names = {1: 'Summer', 3: 'Fall', 5: 'Spring'}
    term = int(year_term_str[-1])

    # Extract fiscal year and convert to actual year
    fiscal_year = int(year_term_str[:-1])
    if term < 5:
        year = fiscal_year - 1
    else:
        year = fiscal_year

    # Return the formatted string with the term name and year
    return f"{term_names.get(term, 'Unknown')} {year}"


def filled_credits(credit_column, variable_credits=1):
    """
    Convert the 'Crds' column in the table to a numeric format,
    filling in variable credits with a specified value.

    Parameters
    ----------
    credit_column : astropy Column
        The column containing credit information, which may include
        variable credits represented as 'Vari.'.
    variable_credits : int, optional
        The value to use for variable credits, by default 1.

    Returns
    ------- 
    np.ndarray
        An array of integer credits, with variable credits replaced
        by the specified value.
    """
    # Identify rows where the credit value is 'Vari.'
    vari_rows = credit_column == 'Vari.'

    # Create a copy of the credit column, masking the variable rows
    # and filling them with the specified variable credits value
    crds = credit_column.copy()
    crds.mask[vari_rows] = True
    crds.fill_value = variable_credits

    # Convert the filled column to float, round it, and then convert
    # to int
    crds = np.round(crds.filled().astype(float)).astype(int)
    return crds


def calc_sch(table, vari_credits=1):
    """
    Calculate total student credit hours generated by courses in this 
    table.

    Parameters
    ----------
    table : astropy Table
        The table containing course data, including 'Crds' and 'Enrolled'
        columns.
    vari_credits : int, optional
        The value to use for variable credits, by default 1.

    Returns
    -------
    int
        The total student credit hours (SCH) calculated as the sum of
        enrolled students multiplied by their respective credits.
    """

    # Fill the 'Crds' column with variable credits where applicable
    crds = filled_credits(table['Crds'], variable_credits=vari_credits)

    # Calculate the total student credit hours by multiplying
    # the number of enrolled students by their respective credits
    # and summing the results
    sch = (table['Enrolled'] * crds).sum()

    return sch


def calc_seats(table):
    """
    Calculate the number of seats that are available, filled, empty, for
    classes that are not canceled.

    Parameters
    ----------
    table : astropy Table
        The table containing course data, including 'Status', 'Size:',
        and 'Enrolled' columns.

    Returns
    -------
    dict
        A dictionary containing the number of empty seats, filled seats,
        and available seats in the courses that are not canceled.
        The keys are 'empty', 'filled', and 'available'.
    """

    # Filter out canceled courses
    not_canceled = table['Status'] != 'Cancelled'
    # Calculate the number of empty seats for courses that are not canceled
    # and where the size is greater than the number of enrolled students.
    empty = table['Size:'] - table['Enrolled']
    # Only keep positive empty seats
    positive = empty > 0
    empty *= positive

    # Sum the empty, filled, and available seats for courses that are 
    # not canceled
    empty = empty[not_canceled].sum()
    available = table['Size:'][not_canceled].sum()
    filled = table['Enrolled'][not_canceled].sum()
    return {'empty': empty, 'filled': filled, 'available': available}


def calc_tuition(table, variable_credits=1):
    """
    Calculate the tuition revenue generated by the courses in the
    table.

    Parameters
    ----------
    table : astropy Table
        The table containing course data, including 'Tuition unit',
        'Crds', 'Tuition -resident', and 'Enrolled' columns.
    variable_credits : int, optional
        The value to use for variable credits, by default 1.

    Returns
    -------
    float
        The total tuition revenue calculated as the sum of enrolled
        students multiplied by their respective tuition amounts, adjusted
        for credit hours if applicable.
    """
    by_credit = table['Tuition unit'] == 'credit'
    credits = filled_credits(table['Crds'],
                             variable_credits=variable_credits)
    tuition_nas = table['Tuition -resident'] == 'n/a'
    table['Tuition -resident'].mask |= tuition_nas
    # parse tuition as a string into a number
    money = [float(m.replace('$', '').replace(',', '')) for m in table['Tuition -resident'].filled(fill_value='0')]
    money *= table['Enrolled']
    money[by_credit] *= credits[by_credit]
    return money.sum()


def gen_cache_file(path, table):
    """
    Generate a name for a cache of a view of the data based on
    the URL path to the view

    Parameters
    ----------
    path : str
        The URL path that got the user here, used to generate a unique
        filename for the cached data.
    table : astropy Table
        The table containing course data to be cached.

    Returns
    -------
    str
        The name of the cached file, which is a CSV file containing the
        course data for the specified view.
    """

    # Compute the average time for all courses in the table.
    avg_time = int(table['timestamp'].mean())

    # path always starts with a leading /, remove it
    rel_path = path[1:]
    parts = rel_path.split('/')
    parts.extend([str(avg_time)])
    name = '-'.join(parts) + '.csv'
    file_path = os.path.join(CACHE_DIR, name)
    if not os.path.isfile(file_path):
        table.write(file_path)
    return name


def match_subject(subject, tbl):
    """
    Match the subject to the table, filtering it down to only the
    relevant courses.

    Parameters
    ----------

    subject : str
        The subject to filter by, which can be a course subject (e.g., 'CSCI'),
        a LASC area ('lasc'), a WI course ('wi'), or '18online' for online courses.
    tbl : astropy Table
        The table containing course data to be filtered.

    Returns
    -------
    astropy Table
        A filtered table containing only the courses that match the specified
        subject. If the subject is 'lasc', it filters for LASC courses; if 'wi',
        it filters for WI courses; if '18online', it filters for online courses;
        if 'all', it returns the entire table; otherwise, it filters by the
        specified course subject.
    """
    
    if subject == 'lasc':
        render_me = tbl[~tbl['LASC/WI'].mask]
        really_lasc = np.array([len(lasc.strip('WI')) > 0 for lasc in render_me['LASC/WI']])
        render_me = render_me[really_lasc]
    elif subject == 'wi':
        render_me = tbl[~tbl['LASC/WI'].mask]
        really_wi = np.array(['WI' in lasc for lasc in render_me['LASC/WI']])
        render_me = render_me[really_wi]
    elif subject == '18online':
        keep = tbl['18online'] == 'True'
        render_me = tbl[keep]
    elif subject == 'all':
        render_me = tbl.copy()
    else:
        # Regular academic subject...
        keep = tbl['Subj'] == subject.upper()
        render_me = tbl[keep]
    return render_me


def common_response(render_me, path):
    """
    Most of what we are returning is the same for all views,
    we just have a bunch of routes for getting there.

    Parameters
    ----------
    render_me : astropy Table
        The table to be rendered in the view.

    path : str
        The URL path that got the user here.

    Returns
    -------
    str
        The rendered HTML template for the course information page,
        including the table, timestamp, most recent term, year terms,
        cache file name, student credit hours, available seats, and
        tuition revenue.
    """
    terms = sorted(set(render_me['year_term']))
    year_terms = ', '.join([parse_year_term(str(t)) for t in terms])
    file_name = gen_cache_file(path, render_me)
    most_recent = int(render_me['timestamp'].max())
    most_recent = datetime.datetime.fromtimestamp(most_recent)
    oldest = render_me['timestamp'].min()
    return render_template('course_info.html', table=render_me,
                           timestamp=int(render_me['timestamp'].mean()),
                           most_recent=most_recent,
                           year_term=year_terms,
                           sch=calc_sch(render_me),
                           filename=file_name,
                           seats=calc_seats(render_me),
                           revenue=calc_tuition(render_me),
                           base_detail_url=COURSE_DETAIL_URL)
